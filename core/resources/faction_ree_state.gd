class_name FactionREEState
extends RefCounted
## FactionREEState tracks REE (Rare Earth Elements) resources for a single faction.
## Provides resource addition, consumption, and analytics tracking.

signal ree_changed(amount: float, change: float, source: String)
signal ree_generation_changed(rate: float)
signal storage_full()
signal insufficient_ree(requested: float, available: float)

## Source types for analytics tracking
enum REESource {
	DESTRUCTION = 0,
	SALVAGE = 1,
	DISTRICT_INCOME = 2,
	UNIT_COLLECTION = 3,
	INITIAL = 4,
	BONUS = 5,
	REFUND = 6
}

## Source type to string mapping
const SOURCE_NAMES := {
	REESource.DESTRUCTION: "destruction",
	REESource.SALVAGE: "salvage",
	REESource.DISTRICT_INCOME: "district_income",
	REESource.UNIT_COLLECTION: "unit_collection",
	REESource.INITIAL: "initial",
	REESource.BONUS: "bonus",
	REESource.REFUND: "refund"
}

## Faction ID this state belongs to
var faction_id: int = 0

## Current REE amount
var current_ree: float = 0.0

## Maximum REE storage capacity
var max_ree_storage: float = 10000.0

## REE generation rate per second (from districts, etc.)
var ree_generation_rate: float = 0.0

## Analytics tracking
var total_ree_generated: float = 0.0
var total_ree_consumed: float = 0.0

## REE generated by source type
var ree_by_source: Dictionary = {}

## REE consumed by category
var ree_consumed_by_category: Dictionary = {}

## Transaction history (for networking/replay - stores recent transactions)
var transaction_history: Array[Dictionary] = []
var max_transaction_history: int = 100


func _init(p_faction_id: int = 0, initial_ree: float = 0.0, max_storage: float = 10000.0) -> void:
	faction_id = p_faction_id
	max_ree_storage = max_storage

	# Initialize source tracking
	for source in SOURCE_NAMES.values():
		ree_by_source[source] = 0.0

	# Set initial REE
	if initial_ree > 0:
		add_ree(initial_ree, "initial")


## Add REE from a source.
## Returns the actual amount added (may be less due to storage cap).
func add_ree(amount: float, source: String = "unknown") -> float:
	if amount <= 0:
		return 0.0

	var space_available := max_ree_storage - current_ree
	var actual_amount := minf(amount, space_available)

	if actual_amount > 0:
		current_ree += actual_amount
		total_ree_generated += actual_amount

		# Track by source
		if ree_by_source.has(source):
			ree_by_source[source] += actual_amount
		else:
			ree_by_source[source] = actual_amount

		# Record transaction
		_record_transaction("add", actual_amount, source)

		ree_changed.emit(current_ree, actual_amount, source)

	# Notify if storage is full
	if current_ree >= max_ree_storage:
		storage_full.emit()

	return actual_amount


## Consume REE for a purpose.
## Returns true if consumption was successful.
func consume_ree(amount: float, category: String = "unknown") -> bool:
	if amount <= 0:
		return true

	if not can_afford(amount):
		insufficient_ree.emit(amount, current_ree)
		return false

	current_ree -= amount
	total_ree_consumed += amount

	# Track by category
	if ree_consumed_by_category.has(category):
		ree_consumed_by_category[category] += amount
	else:
		ree_consumed_by_category[category] = amount

	# Record transaction
	_record_transaction("consume", amount, category)

	ree_changed.emit(current_ree, -amount, category)
	return true


## Check if faction can afford a REE cost.
func can_afford(amount: float) -> bool:
	return current_ree >= amount


## Query available REE (non-modifying).
func get_available_ree() -> float:
	return current_ree


## Get storage percentage (0.0 to 1.0).
func get_storage_percentage() -> float:
	if max_ree_storage <= 0:
		return 0.0
	return clampf(current_ree / max_ree_storage, 0.0, 1.0)


## Check if storage is full.
func is_storage_full() -> bool:
	return current_ree >= max_ree_storage


## Set generation rate.
func set_generation_rate(rate: float) -> void:
	if rate < 0:
		rate = 0
	ree_generation_rate = rate
	ree_generation_changed.emit(rate)


## Apply generation (called per frame/tick).
func apply_generation(delta: float) -> float:
	if ree_generation_rate <= 0:
		return 0.0
	return add_ree(ree_generation_rate * delta, "district_income")


## Increase max storage.
func increase_max_storage(amount: float) -> void:
	max_ree_storage += amount


## Set max storage directly.
func set_max_storage(amount: float) -> void:
	max_ree_storage = maxf(amount, 0.0)
	# Clamp current REE if above new max
	if current_ree > max_ree_storage:
		current_ree = max_ree_storage


## Record a transaction for history.
func _record_transaction(type: String, amount: float, category: String) -> void:
	var transaction := {
		"type": type,
		"amount": amount,
		"category": category,
		"timestamp": Time.get_ticks_msec(),
		"balance_after": current_ree
	}

	transaction_history.append(transaction)

	# Trim history if too long
	while transaction_history.size() > max_transaction_history:
		transaction_history.pop_front()


## Get transaction history.
func get_transaction_history() -> Array[Dictionary]:
	return transaction_history


## Clear transaction history.
func clear_transaction_history() -> void:
	transaction_history.clear()


## Get analytics summary.
func get_analytics() -> Dictionary:
	return {
		"faction_id": faction_id,
		"current_ree": current_ree,
		"max_ree_storage": max_ree_storage,
		"ree_generation_rate": ree_generation_rate,
		"storage_percentage": get_storage_percentage(),
		"total_generated": total_ree_generated,
		"total_consumed": total_ree_consumed,
		"net_gain": total_ree_generated - total_ree_consumed,
		"by_source": ree_by_source.duplicate(),
		"consumed_by_category": ree_consumed_by_category.duplicate()
	}


## Reset state (for new game).
func reset(initial_ree: float = 0.0) -> void:
	current_ree = 0.0
	ree_generation_rate = 0.0
	total_ree_generated = 0.0
	total_ree_consumed = 0.0

	for source in ree_by_source:
		ree_by_source[source] = 0.0

	ree_consumed_by_category.clear()
	transaction_history.clear()

	if initial_ree > 0:
		add_ree(initial_ree, "initial")


## Serialize state.
func to_dict() -> Dictionary:
	return {
		"faction_id": faction_id,
		"current_ree": current_ree,
		"max_ree_storage": max_ree_storage,
		"ree_generation_rate": ree_generation_rate,
		"total_ree_generated": total_ree_generated,
		"total_ree_consumed": total_ree_consumed,
		"ree_by_source": ree_by_source.duplicate(),
		"ree_consumed_by_category": ree_consumed_by_category.duplicate()
	}


## Deserialize state.
func from_dict(data: Dictionary) -> void:
	faction_id = data.get("faction_id", 0)
	current_ree = data.get("current_ree", 0.0)
	max_ree_storage = data.get("max_ree_storage", 10000.0)
	ree_generation_rate = data.get("ree_generation_rate", 0.0)
	total_ree_generated = data.get("total_ree_generated", 0.0)
	total_ree_consumed = data.get("total_ree_consumed", 0.0)
	ree_by_source = data.get("ree_by_source", {}).duplicate()
	ree_consumed_by_category = data.get("ree_consumed_by_category", {}).duplicate()

	# Ensure all sources exist
	for source in SOURCE_NAMES.values():
		if not ree_by_source.has(source):
			ree_by_source[source] = 0.0


## Get compact summary for debugging.
func get_summary() -> Dictionary:
	return {
		"faction_id": faction_id,
		"current": current_ree,
		"max": max_ree_storage,
		"rate": ree_generation_rate,
		"generated": total_ree_generated,
		"consumed": total_ree_consumed
	}
